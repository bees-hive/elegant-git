#!/usr/bin/env bash
set -e

command-purpose() {
    cat <<MESSAGE
Incorporates a branch on top of the \`master\`.
MESSAGE
}

command-synopsis() {
    cat <<MESSAGE
usage: git elegant accept-work <branch>
MESSAGE
}

command-description() {
    cat<<MESSAGE
Checkouts a given local or remote branch into a temporary one. Then, it makes
a rebase of the latest version of the default upstream branch (\`master\`) with
current changes. The final rebased index merges using fast-forward strategy
into the default local branch and pushes into the default upstream branch
(\`origin/master\`). After a successful push, the temporary branch is removed
as well as the given branch if it locates in \`origin\` remote.

If there is a rebase in progress and it is initiated by this command, it will
be continued instead; otherwise, the command stops.

The command uses branch and stash pipes to preserve the current Git state prior
to execution and restore after.

Approximate commands flow is
\`\`\`bash
==>> git elegant accept-work task-123
git fetch --all
git checkout --force -B __eg origin/task-123
git rebase origin/master
git checkout master
git merge --ff-only __eg
git push origin master:master
git branch --delete --force __eg
git push origin --delete task-123
\`\`\`
MESSAGE
}

--accept-work-logic() {
    local work_branch="__eg"
    local changes=${1}
    source ${BINS}/plugins/state
    if is-there-active-rebase; then
        local rb=$(rebasing-branch)
        if [[ ${work_branch} == ${rb} ]]; then
            git-verbose rebase --continue
        else
            error-text "First, please complete current rebase which updates '${rb}' branch."
            exit 43
        fi
    else
        _error-if-empty "${changes}" "Please provide a branch name."
        if git rev-parse --verify --quiet --abbrev-ref --branches=refs/heads ${changes} >/dev/null; then
            git-verbose fetch --all
            git-verbose checkout -B ${work_branch} ${changes}
        else
            git elegant obtain-work "${changes}" "${work_branch}"
        fi
        if are-there-remotes; then
            git-verbose rebase ${RMASTER}
        else
            git-verbose rebase ${MASTER}
        fi
    fi
    local actual_remote=$(git for-each-ref --format='%(upstream:short)' refs/heads/${work_branch})
    git-verbose checkout ${MASTER}
    git-verbose merge --ff-only ${work_branch}
    git-verbose branch --delete --force ${work_branch}
    if are-there-remotes; then
        git-verbose push ${REMOTE_NAME} ${MASTER}:${MASTER}
        if [[ ${actual_remote} =~ ^origin/ ]];  then
            git-verbose push ${REMOTE_NAME} --delete $(branch-from-remote-reference ${actual_remote})
        fi
    fi
}

default() {
    stash-pipe branch-pipe --accept-work-logic "${@}"
}
